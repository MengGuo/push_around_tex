%==============================
\subsection{Overall Analyses}\label{subsec:overall}
%==============================
%----------------------------------------------
\subsubsection{Online Execution and Adaptation}\label{subsec:execute}
%----------------------------------------------
After the search returns a push sequence $\texttt{Plan}=\{\tau_1,\ldots,\tau_K\}$,
execution proceeds \emph{sequentially} with an online hybrid controller that
alternates between \textbf{transition} (robots move to contact) and \textbf{pushing}
(robots regulate while the object moves).

\paragraph{Controller overview.}
Each task $\tau_k$ specifies a target obstacle and a world-frame twist
$\widehat{\mathbf{u}}=(\widehat{v}_x,\widehat{v}_y,\widehat{\omega})$ for a short
horizon. We synthesize a reference object trajectory by integrating
$\widehat{\mathbf{u}}$ and map it to per-robot reference contact states using the
active contact mode. Robots are commanded by proportional velocity control on
position/yaw errors at their \emph{contact-centric} targets:
\[
\mathbf{v}_n = K_{\!p}\!\left(\widehat{\mathbf{p}}^{\,\text{c}}_n - \mathbf{p}^{\text{c}}_n\right),
\qquad
\omega_n = K_{\!r}\!\left(\widehat{\psi}^{\,\text{c}}_n - \psi^{\text{c}}_n\right),
\]
with periodic \emph{forward-reference refresh} to remain predictive. During
transition, each robot plans a collision-free path (grid/A*) to a small offset of
its contact pose; a lightweight conflict check swaps a pair of goal contacts if two
transition paths are imminently head-on. During pushing, small contact-frame offsets
are adapted online to absorb object yaw drift, keeping contact consistent without
re-planning.

\paragraph{Task switching and re-planning.}
Execution monitors (i) transition feasibility/timeouts and (ii) pushing progress via
a short-horizon early-stop test that triggers when the commanded widening succeeds
or progress stalls. On task completion, the executor advances to $\tau_{k+1}$. If a
failure/stall is detected, execution yields control back to the planner with the
current snapshot. Previously explored but unexecuted nodes are \emph{preserved} and
reinserted by priority, avoiding priority-queue exhaustion and continuing from the
most promising frontier.

\paragraph{Global goal check.}
At a coarse cadence, the system rebuilds the $W$-clearance graph on the live
snapshot and terminates the episode as soon as a $W$-clear path exists from start
to goal; this prevents unnecessary additional pushes once connectivity is achieved.

\begin{remark}[Endpoint disks as a sufficiency booster]
The $W$-CCG connectivity test is necessary but may be conservative at the path
endpoints. We therefore include a lightweight \emph{endpoint-clearing} supplement:
if connectivity holds but either endpointâ€™s $W/2$ disk is contaminated, the planner
proposes a small set of \emph{away-from-endpoint} pushes to clear the disk, after
which execution proceeds. This is an implementation convenience rather than a core
component of the method.
\end{remark}

%----------------------------------------------
\subsubsection{Complexity (Core Conclusions)}\label{subsubsec:complexity}
%----------------------------------------------
Per expansion, the dominant cost is parallel prediction of a small batch of push
candidates; frontier/$W$-connectivity and gap presearch are typically subdominant.

\[
T_{\text{exp}} \;\approx\; \tilde{\mathcal O}(M) \;+\; \mathcal O(BD) \;+\; \frac{K}{P}\!\left(T_{\text{qp}} + S\,T_{\text{phys}}\right),
\]
where $M$ is \#obstacles, $B/D$ are beam width/depth for presearch, $K$ candidates per
expansion, $P$ worker processes, $S$ average physics steps (post quick-pass/early-stop),
$T_{\text{qp}}$ geometry screen time, and $T_{\text{phys}}$ per-step physics time.

\noindent\textbf{Implications.}
(i) ModeTable and beam presearch reduce $K$ and keep $BD\!\ll\!M$;
(ii) quick-pass/early-stop cut $S$ and the simulator hit-rate;
(iii) increasing $P$ yields near-linear speedup until IPC bounds;
(iv) deferred reinsertion keeps expansions focused, avoiding wasted restarts.

%----------------------------------------------
\subsubsection{Generalization and limits}\label{subsec:general}
%----------------------------------------------
\textbf{Heterogeneous teams.} The controller already exposes per-robot gains and
supports basic heterogeneity during transition (e.g., avoiding goal swaps across
mismatched capability classes). Extending the ModeTable prior with robot-specific
limits is straightforward. \textbf{Sequential vs.\ concurrent pushes.} The current
executor applies one push task at a time; concurrent pushing is a natural extension
but requires multi-object mode synthesis and conflict-aware transitions. \textbf{Dynamic
changes.} Because the executor performs periodic global $W$-connectivity checks and
re-plans on failure, modest perturbations (e.g., small drifts or unmodeled contacts)
are handled online without restarting the episode.