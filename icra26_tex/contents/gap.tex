\subsection{Gap Ranking Strategy}
\label{subsec:gap}

When no clearance-$W$ path exists, we rank blocking gaps on the reachable
\emph{frontier} to decide where to clear first. Our ranking is \emph{search-
based}: it estimates the end-to-end \emph{cost-to-connect} from the current
state to the goal if we first cross a candidate gap and then continue crossing
additional frontiers until a $W$-feasible path emerges.

%==============================
\subsubsection{Frontier and Candidates}
\label{subsubsec:gap-frontier}
Given start $\mathbf{s}^{\texttt{S}}$ and goal $\mathbf{s}^{\texttt{G}}$, we run
a bug-style planner on the WCCG to either (i) certify direct connectivity or
(ii) return a counter-clockwise frontier loop $\mathcal{L}$ separating
$\mathbf{s}^{\texttt{S}}$ and $\mathbf{s}^{\texttt{G}}$ (cf. Sec.~\ref{subsubsec:bugplanner-connectivity}).
Let $\mathcal{G}(\mathcal{L})=\{g_1,\ldots,g_K\}$ be the set of (visible)
bridgeâ€“bridge gaps lying on $\mathcal{L}$. These $K$ gaps are the first-hop
candidates.

\subsubsection{Step Cost Model}
\label{subsubsec:gap-cost}
For a gap $g\in\mathcal{G}(\mathcal{L})$ we define a \emph{step} cost that
captures approach effort and the required widening (scaled by mass):
\begin{equation}\label{eq:step-cost}
J(g\mid\mathcal{L},\mathbf{s})
= \lambda_{\mathrm{trans}}\,\mathsf{C}_{\mathrm{trans}}(\mathbf{s},\mathcal{L},g)
+ \lambda_{\mathrm{push}}\,\mathsf{C}_{\mathrm{push}}(g).
\end{equation}
Here (i) $\mathsf{C}_{\mathrm{trans}}$ is the straight-line distance from the
current robot center $\mathbf{s}$ to an outside insertion point of $g$ on
$\mathcal{L}$; (ii) the widening cost is
\begin{equation}\label{eq:push-cost}
\mathsf{C}_{\mathrm{push}}(g)
= \kappa(g)\,\big[\max\{0,\,W-w(g)\}+\delta\big],
\end{equation}
where $w(g)$ is the current gap width, $\delta>0$ is a small safety margin, and
$\kappa(g)=\phi\!\big(\min\{M_u,M_v\}\big)\ge 1,$ scales the geometric requirement by a mass-dependent factor using
the lighter adjacent obstacle masses $M_u,M_v$. The nonnegative weights
$\lambda_{\mathrm{trans}}$ and $\lambda_{\mathrm{push}}$ trade off the two terms.
To guide search we use a consistent one-step heuristic
\begin{equation}\label{eq:gap-heuristic}
  h(g) \;=\; \eta \,\big\|\mathbf{o}(g)-\mathbf{s}^{\texttt{G}}\big\|_2,
\end{equation}
where $\mathbf{o}(g)$ is the outside point associated with $g$ and
$\eta>0$ is a scaling factor.

%==============================
\subsubsection{Presearch and Ranking Score}
\label{subsubsec:gap-ranking-rule}
Starting from the initial frontier $\mathcal{L}$, each first-hop candidate
$g\in\mathcal{G}(\mathcal{L})$ is evaluated by a greedy beam/A$^\ast$-like
\emph{presearch} that repeatedly: (i) crosses $g$, (ii) computes the next
frontier $\mathcal{L}'$ with the bug planner, and (iii) enqueues the
top-$B$ gaps on $\mathcal{L}'$ by the priority
\(
f \,=\, g\text{-cost} + J(\cdot) + h(\cdot).
\)
The presearch terminates either when the goal becomes directly visible
(connected) or when the depth/queue budget is exceeded. For a first-hop $g$,
the predicted end-to-end cost is
\begin{equation}\label{eq:total-cost}
\widehat{\mathsf{Cost}}(g)
= J\big(g \mid \mathcal{L}, \mathbf{s}^{\texttt{S}}\big)
+ \sum\nolimits_{g'\in\Pi^*(g)} J\big(g' \mid \cdot\big).
\end{equation}
where $\Pi^*(g)$ is the subsequent gap sequence chosen by the presearch from
the new frontier after crossing $g$. We then rank candidates in ascending order
of $\widehat{\mathsf{Cost}}(g)$.
% \begin{equation}\label{eq:rank-score}
%   \mathsf{Rank}(g_1)\le\mathsf{Rank}(g_2) \;\;\Longleftrightarrow\;\;
%   \widehat{\mathsf{Cost}}(g_1) \le \widehat{\mathsf{Cost}}(g_2).
% \end{equation}
Intuitively, the top-ranked gap offers the best predicted connectivity
improvement per unit effort, accounting for both the first crossing and the
downstream crossings it enables.

%==============================
\subsubsection{Notes on Efficiency}
\label{subsubsec:eff-notes}
We cache frontier loops by a loop signature and memoize transitions
$(\text{loop},g)\!\mapsto\!\text{loop}'$ to avoid recomputation. Nearest
edge hits for ray shooting are computed in a vectorized manner with AABB
culling, yielding near-linear time per shoot in the number of visible edges.
\begin{algorithm}[t]
\caption{Gap Ranking via Frontier Presearch}
\label{alg:gap-ranking}
\DontPrintSemicolon
\KwIn{$\mathbf{s}^{\texttt{S}}$, $\mathbf{s}^{\texttt{G}}$, WCCG, $\lambda_{\mathrm{trans}}$, $\lambda_{\mathrm{push}}$}
\KwOut{Frontier gaps ranked by predicted cost}
$(\mathcal{L}, \texttt{connected}) \leftarrow \mathrm{BugPlannerFrontier}(\mathbf{s}^{\texttt{S}},\mathbf{s}^{\texttt{G}})$\;
\If{\texttt{connected}}{\Return $\emptyset$}
$\mathcal{C} \leftarrow$ bridge--bridge gaps on $\mathcal{L}$\;
\ForEach{$g \in \mathcal{C}$}{
  $J_1 \leftarrow \lambda_{\mathrm{trans}}\mathsf{C}_{\mathrm{trans}} + \lambda_{\mathrm{push}}\kappa(g)[\max(0, W-w(g))+\delta]$\;
  $(\texttt{succ}, J_{\mathrm{tail}}, \Pi) \leftarrow \mathrm{PresearchAfter}(g,\mathbf{s}^{\texttt{S}},\mathbf{s}^{\texttt{G}})$\;
  $\widehat{\mathrm{Cost}}(g) \leftarrow J_1 + (\texttt{succ} ? J_{\mathrm{tail}} : \infty)$\;
}
\Return $\mathrm{argsort}_{g\in\mathcal{C}}\,\widehat{\mathrm{Cost}}(g)$ (ascending)\;
\end{algorithm}