%==============================================
%==============================
\begin{algorithm}[t]
\small
\caption{SiLS with Deferred Expansion (compact)}
\label{alg:SiLS}
\DontPrintSemicolon
\SetKwInOut{Input}{In}\SetKwInOut{Output}{Out}
\Input{$\mathbf{s}^{\texttt{S}}$, $\mathbf{s}^{\texttt{G}}$, $W$, initial \texttt{Snap}, batch size $B$}
\Output{Executable push plan or \texttt{fail}}
Initialize node $\nu_0=(\texttt{Snap}_0,\emptyset,g{=}0)$, set $\mathcal{C}(\nu_0)\leftarrow\varnothing$, $j(\nu_0)\leftarrow 0$;\\
$\texttt{PQ}\leftarrow\{(\nu_0,f{=}\widehat{\mathsf{Cost}}_{\text{to-go}})\}$\;
\While{\texttt{PQ} not empty}{
  Pop $\nu$ with minimal $f$; \\
  \If{$\mathcal{C}(\nu)=\varnothing$}{
    Build WCCG from \texttt{Snap}; \If{connected}{\Return \texttt{Plan}} 
    $(\mathcal{L},\texttt{conn}) \leftarrow \texttt{BugPlannerFrontier}(\mathbf{s}^{\texttt{S}},\mathbf{s}^{\texttt{G}})$; \\
    Rank gaps on $\mathcal{L}$ by presearch; build $\mathcal{C}(\nu)$ as a ranked list of push tasks; set $j(\nu)\leftarrow 0$;
  }
  Take next batch $\mathcal{B}\leftarrow\mathcal{C}(\nu)[\,j(\nu):j(\nu){+}B\,]$; $j(\nu)\leftarrow j(\nu){+}|\mathcal{B}|$; \\
  \ForEach{$\tau\in\mathcal{B}$ in parallel}{
    $(\texttt{ok}, \texttt{Snap}', t_\text{push}) \leftarrow \texttt{SimPredict}(\tau)$; \\
    \If{\texttt{ok}}{
      $\Delta g \leftarrow \mathsf{C}_{\mathrm{trans}} + t_\text{push}$;\quad
      $g' \leftarrow g+\Delta g$;\quad
      $h' \leftarrow \widehat{\mathsf{Cost}}_{\text{to-go}}(\texttt{Snap}')$;\\
      Push child $\nu'=(\texttt{Snap}',\texttt{Plan}\!\cup\!\{\tau\},g')$ with $f'=g'+h'$ into \texttt{PQ};
    }
  }
  \If{$j(\nu)<|\mathcal{C}(\nu)|$}{reinsert $\nu$ into \texttt{PQ} with priority $f$}
}
\Return \texttt{fail} \; (all nodes exhausted)
\end{algorithm}

\subsection{Simulation-in-the-Loop Search}
\label{subsec:simloop}

We integrate dynamics feasibility into planning by embedding a fast, parallel physics predictor inside the search loop. Each expansion proposes concrete push actions, validates them in simulation, and re-estimates clearance-$W$ connectivity via the WCCG presearch. This closes the gap between graph reasoning and executable plans.

%==============================
\subsubsection{Node and Priority (with Deferred Expansion)}
\label{subsubsec:simloop-node}
A node stores the current world snapshot and partial plan, \(
\nu=(\texttt{Snap},\texttt{Plan},g)
\), plus a lazily constructed, ranked candidate list for that snapshot:
\[
\mathcal{C}(\nu)=\{\,\text{gap}\to\text{tasks}\,\},\quad
j(\nu)\in\{0,\dots,|\mathcal{C}|-1\}
\]
where \(j(\nu)\) is a cursor pointing to the next untried batch. We use
\begin{equation}\label{eq:simloop-priority}
  f(\nu)=g(\nu)+\widehat{\mathsf{Cost}}_{\text{to-go}}(\texttt{Snap}),
\end{equation}
with \(\widehat{\mathsf{Cost}}_{\text{to-go}}\) from the WCCG frontier presearch (Sec.~\ref{subsec:gap}). The incremental execution cost of one push is
\[
\Delta g=\mathsf{C}_{\mathrm{trans}}(\text{robots}\!\to\!\text{target})+\texttt{pushing\_time}.
\]

%==============================
\subsubsection{Simulation-Guided Expansion (Progressive)}
\label{subsubsec:simloop-expansion}
When a node is popped, we \emph{defer} full branching: (i) if \(\mathcal{C}\) is uninitialized, build WCCG, extract the frontier loop, rank gaps by presearch, and generate a small set of push tasks per top gap (ModeTable prior $\rightarrow$ directions; fallback “away\,+\,jitter”); (ii) simulate only the next \(B\) untried tasks starting at cursor \(j\) (in parallel, with quick-pass and early-stop); (iii) push any successful children; (iv) if untried candidates remain, \emph{reinsert the parent node} with \(j\leftarrow j+B\). Thus the PQ never empties unless \emph{all} nodes have exhausted their candidates.


%==============================
\paragraph{Efficiency notes.}
(1) \textbf{Frontier caching.} BugPlanner caches loop signatures and transitions $(\mathcal{L},g)\!\mapsto\!\mathcal{L}'$, and uses vectorized ray--edge hits with AABB culling.  
(2) \textbf{Parallel pool.} Prediction environments are pre-forked (spawn) and reused; each round broadcasts only the snapshot and reachable contacts; we use \texttt{imap\_unordered}.  
(3) \textbf{Quick-pass \& early-stop.} A geometry-only screen can skip physics if the reference rollout clears the gap safely; otherwise the physics loop stops as soon as widening succeeds or progress stalls.  
(4) \textbf{Directional prior.} The ModeTable concentrates sampling on low-loss, well-aligned pushes while preserving exploration via a temperature-controlled softmax.  
(5) \textbf{Deferred expansion.} By batching only the next \(B\) tasks and reinserting partially expanded nodes, the PQ remains nonempty until every node’s candidates are exhausted; this avoids premature termination when sampling is sparse.
