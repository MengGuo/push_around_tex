
\begin{algorithm}[t]
\small
\caption{SiLS with Deferred Expansion (clean version)}
\label{alg:SiLS}
\DontPrintSemicolon
\SetKwInOut{Input}{In}\SetKwInOut{Output}{Out}
\SetKwFunction{Build}{BuildWCCG}
\SetKwFunction{Frontier}{BugPlannerFrontier}
\SetKwFunction{Rank}{PresearchRank}
\SetKwFunction{Predict}{SimPredict}
\SetKwFunction{Next}{NextBatch}

\Input{$\mathbf{s}^{\texttt{S}}$, $\mathbf{s}^{\texttt{G}}$, $W$, initial snapshot, batch size $B$}
\Output{Executable push plan or \texttt{fail}}

\BlankLine
\textbf{State of a node:} $\nu=(\texttt{snap}, \texttt{plan}, g, \mathcal{C}, j)$,
with candidates $\mathcal{C}$ (ranked) and cursor $j$.\;

\BlankLine
\textbf{Init:} $\nu_0\!\leftarrow\!(\texttt{snap}_0,\emptyset,0,\varnothing,0)$;\;
$\texttt{PQ}\!\leftarrow\!\{(\nu_0, f=\widehat{\mathsf{Cost}}_{\text{to-go}}(\texttt{snap}_0))\}$\;

\While{\texttt{PQ} not empty}{
  Pop $(\nu,f)$ with minimal $f$; \tcp*{$\nu=(\texttt{snap},\texttt{plan},g,\mathcal{C},j)$}
  \If{$\mathcal{C}=\varnothing$}{
    $(\texttt{connected}) \leftarrow \Build(\texttt{snap})$;\;
    \If{\texttt{connected}}{\Return \texttt{plan}}
    $\mathcal{L}\leftarrow \Frontier(\mathbf{s}^{\texttt{S}},\mathbf{s}^{\texttt{G}})$;\;
    $\mathcal{C}\leftarrow \Rank(\mathcal{L})$;\; $j\leftarrow 0$\;
  }
  $\mathcal{B}\leftarrow \Next(\mathcal{C}, j, B)$;\; $j\leftarrow j+|\mathcal{B}|$\;

  \ForEach{$\tau\in\mathcal{B}$ \textbf{in parallel}}{
    $(\texttt{ok}, \texttt{snap}', t_\text{push}) \leftarrow \Predict(\tau)$\;
    \If{\texttt{ok}}{
      $g' \leftarrow g + \mathsf{C}_{\mathrm{trans}} + t_\text{push}$;\;
      $h' \leftarrow \widehat{\mathsf{Cost}}_{\text{to-go}}(\texttt{snap}')$;\;
      Push $\big((\texttt{snap}',\,\texttt{plan}\!\cup\!\{\tau\},\,g',\,\varnothing,\,0),\, f'=g'+h'\big)$ into \texttt{PQ}\;
    }
  }
  \If{$j<|\mathcal{C}|$}{reinsert current $\nu$ into \texttt{PQ} with the same $f$}
}
\Return \texttt{fail}\;
\end{algorithm}


%----------------------------------------------
% Helper semantics (informal):
%   BuildCandidates(S; s^S, s^G, W): build WCCG at S; if connected return (true, ·);
%     else return (false, ranked push-task list from frontier-gap presearch).
%   Predict(τ): quick-pass → (optional) short-horizon physics; returns (ok, S', t_push).
%   Heuristic(S): WCCG-based cost-to-go from snapshot S.

\subsection{Simulation-in-the-Loop Search}
\label{subsec:simloop}
We embed a parallel physics predictor into search. Each expansion proposes ranked push tasks, filters them by a geometry \emph{quick-pass} and a short-horizon simulation with \emph{early-stop}, and refreshes the $W$-connectivity heuristic via frontier presearch—closing the gap between graph reasoning and executable actions. We refer to this two-stage filter as \emph{the pipeline} below.

\subsubsection{Nodes \& Priority (Deferred Expansion)}
A node $\nu=(\texttt{snapshot},\texttt{plan},g)$ keeps a lazily built, ranked candidate list $\mathcal{C}(\nu)$ and a cursor $j(\nu)$ to the next untried batch. We use a best-first score
\[
f(\nu)=g(\nu)+\widehat{\mathsf{Cost}}_{\text{to-go}}(\texttt{snapshot}),
\]
where $g$ accumulates robot transit plus predicted push time, and $\widehat{\mathsf{Cost}}_{\text{to-go}}$ comes from the frontier presearch (Sec.~\ref{subsec:gap}).

\subsubsection{Progressive Expansion}
When a node \(\nu\) is popped, we expand it \emph{progressively}.

\textbf{Initialize on demand.}
If \(\mathcal{C}(\nu)\) is empty, we (a) build the WCCG and extract one frontier loop via BugPlanner, (b) rank its bridge–bridge gaps by the frontier presearch, and (c) instantiate a few push tasks per top gap (ModeTable prior; fallback \emph{away\,+\,jitter}). Set \(j(\nu)=0\).

\textbf{Evaluate a small slice.}
Take the next \(B\) tasks
\(
\mathcal{B}=\mathcal{C}(\nu)[\,j(\nu):\,j(\nu){+}B\,],
\)
advance \(j(\nu)\!\leftarrow\!j(\nu){+}|\mathcal{B}|\),
and evaluate \(\mathcal{B}\) in parallel through \emph{the pipeline}.
Each successful task \(\tau\) yields a child \(\nu'\) with updated snapshot, cost \(g'\), and priority \(f'=g'+\widehat{\mathsf{Cost}}_{\text{to-go}}\).

\textbf{Reinsert if unfinished.}
If \(j(\nu)<|\mathcal{C}(\nu)|\), reinsert \(\nu\) into the PQ with the \emph{same} priority \(f(\nu)\) to preserve best-first ordering across partially expanded nodes and avoid PQ starvation.

\subsubsection{Collaborative Pushing in Parallel Prediction}
\label{subsubsec:mode-cache}
Each candidate task \(\tau\) specifies a target gap and a short-horizon body twist \(\mathbf{v}=(v_x,v_y,\omega)\).
We synthesize per-robot contact modes \(\boldsymbol{\xi}\) aligned with \(\mathbf{v}\), validate \((\boldsymbol{\xi},\mathbf{v})\) via \emph{the pipeline}, and reuse verified modes within the subtree.

\textbf{Reachable contact region from WCCG/BugPlanner.}
We reuse the same machinery with \(W\) set to the robot’s circumscribed diameter, yielding the \emph{reachable band} on the target boundary (convex pieces) for non–point robots.
We uniformly sample contact points on this band and attach local frames \((\mathbf{n},\tau)\) (see Fig.~\ref{fig:reach-contacts}).

\textbf{Greedy mode search on sampled contacts.}
Given the desired body-frame velocity (arc tracker), we greedily assemble a contact assignment across robots using the objective of~\cite{tang2024collaborative} (balanced normal support, torque leverage, slip margin), restricted to the sampled candidates. This returns a small set of locally optimal modes \(\{\boldsymbol{\xi}\}\) for the requested velocity bin.

\textbf{Online reuse.}
Verified \((\boldsymbol{\xi},\mathbf{v})\) pairs and summary stats (tracking error, success rate, push time) are cached for the current expansion and descendants; a lightweight ModeTable acts as a persistent cache across scenes, exploiting the near-invariance of feasible modes for arc-like motions on a given shape. Only a few hundred entries per shape typically cover most velocity directions.

\subsubsection{Efficiency Notes}
Frontier loops are cached (loop signatures; $(\mathcal{L},g)\!\mapsto\!\mathcal{L}'$ memoization), ray casts are vectorized with AABB culling, predictor workers are pre-forked and reused, and deferred expansion keeps the PQ nonempty until all candidates are tried.
